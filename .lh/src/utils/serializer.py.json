{
    "sourceFile": "src/utils/serializer.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 8,
            "patches": [
                {
                    "date": 1739042664365,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1739042830592,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -68,13 +68,24 @@\n     def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n         \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n         raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n         return cls.from_bytes(raw_bytes)\r\n+    \r\n+    @classmethod\r\n+    def from_raw_floats(cls, fs: List[float]) -> 'SerializedBlock':\r\n+        return SerializedBlock(\r\n+            center_x=int(fs[0]),\r\n+            center_y=int(fs[1]),\r\n+            width=int(fs[2]),\r\n+            height=int(fs[3]),\r\n+            angle=fs[4],\r\n+            color=int(fs[5]),\r\n+        )\r\n \r\n def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n     \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n     serialized_blocks = [SerializedBlock.from_block(block) for block in blocks]\r\n-    return [f for serialized_block in serialized_blocks for f in serialized_block.pack_to_floats()]\r\n+    return [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n \r\n def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n     \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n     assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n"
                },
                {
                    "date": 1739042891564,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,93 @@\n+from src.block import Block\r\n+from ctypes import Structure, c_int16, c_int32, c_float\r\n+import struct\r\n+from typing import Tuple, Optional, List\r\n+from enum import Enum\r\n+\r\n+class SerializedColor(Enum):\r\n+    YELLOW = 1\r\n+    RED = 2\r\n+    BLUE = 4\r\n+\r\n+def get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n+    \"\"\"Maps detected color names to their corresponding SerializedColor enum based on keyword matching.\"\"\"\r\n+    color_name_upper = color_name.upper()\r\n+\r\n+    for enum_member in SerializedColor:\r\n+        if enum_member.name in color_name_upper:\r\n+            return enum_member\r\n+\r\n+    return None  # Return None if no match is found\r\n+\r\n+class SerializedBlock(Structure):\r\n+    _pack_ = 1  # No padding\r\n+    _fields_ = [\r\n+        (\"center_x\", c_int16),\r\n+        (\"center_y\", c_int16),\r\n+        (\"width\", c_int16),\r\n+        (\"height\", c_int16),\r\n+        (\"angle\", c_float),\r\n+        (\"color\", c_int32)\r\n+    ]\r\n+\r\n+    def __str__(self) -> str:\r\n+        return f\"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})\"\r\n+\r\n+    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n+        \"\"\"Packs the structure into four floats.\"\"\"\r\n+        raw_bytes = bytes(self)\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        f1, f2, f3, f4 = struct.unpack('<4f', raw_bytes)\r\n+        return f1, f2, f3, f4\r\n+    \r\n+    def serialize_to_float(self) -> List[float]:\r\n+        \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n+        return [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]\r\n+\r\n+    @staticmethod\r\n+    def from_block(block: 'Block') -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n+        color_enum = get_serialized_color(block.color.name)\r\n+        assert color_enum is not None, f\"Unknown color: {block.color}\"\r\n+        return SerializedBlock(\r\n+            center_x=int(block.center[0]),  # Ensure int conversion\r\n+            center_y=int(block.center[1]),\r\n+            width=int(block.size[0]),\r\n+            height=int(block.size[1]),\r\n+            angle=float(block.angle),  # Ensure float conversion\r\n+            color=color_enum.value  # Store enum as int\r\n+        )\r\n+\r\n+    @classmethod\r\n+    def from_bytes(cls, raw_bytes: bytes) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from raw bytes.\"\"\"\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        return cls.from_buffer_copy(raw_bytes)\r\n+\r\n+    @classmethod\r\n+    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n+        raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n+        return cls.from_bytes(raw_bytes)\r\n+    \r\n+    @classmethod\r\n+    def from_raw_floats(cls, fs: List[float]) -> 'SerializedBlock':\r\n+        return SerializedBlock(\r\n+            center_x=int(fs[0]),\r\n+            center_y=int(fs[1]),\r\n+            width=int(fs[2]),\r\n+            height=int(fs[3]),\r\n+            angle=fs[4],\r\n+            color=int(fs[5]),\r\n+        )\r\n+\r\n+def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n+    \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n+    serialized_blocks = [SerializedBlock.from_block(block) for block in blocks]\r\n+    return [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n+\r\n+def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n+    \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n+    assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n+    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(0, len(floats), 6)]\r\n+    return serialized_blocks\r\n"
                },
                {
                    "date": 1739043229998,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -82,105 +82,12 @@\n         )\r\n \r\n def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n     \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n-    serialized_blocks = [SerializedBlock.from_block(block) for block in blocks]\r\n+    serialized_blocks = [[0, 0]] + [SerializedBlock.from_block(block) for block in blocks]\r\n     return [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n \r\n def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n     \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n     assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n     serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(0, len(floats), 6)]\r\n     return serialized_blocks\r\n-from src.block import Block\r\n-from ctypes import Structure, c_int16, c_int32, c_float\r\n-import struct\r\n-from typing import Tuple, Optional, List\r\n-from enum import Enum\r\n-\r\n-class SerializedColor(Enum):\r\n-    YELLOW = 1\r\n-    RED = 2\r\n-    BLUE = 4\r\n-\r\n-def get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n-    \"\"\"Maps detected color names to their corresponding SerializedColor enum based on keyword matching.\"\"\"\r\n-    color_name_upper = color_name.upper()\r\n-\r\n-    for enum_member in SerializedColor:\r\n-        if enum_member.name in color_name_upper:\r\n-            return enum_member\r\n-\r\n-    return None  # Return None if no match is found\r\n-\r\n-class SerializedBlock(Structure):\r\n-    _pack_ = 1  # No padding\r\n-    _fields_ = [\r\n-        (\"center_x\", c_int16),\r\n-        (\"center_y\", c_int16),\r\n-        (\"width\", c_int16),\r\n-        (\"height\", c_int16),\r\n-        (\"angle\", c_float),\r\n-        (\"color\", c_int32)\r\n-    ]\r\n-\r\n-    def __str__(self) -> str:\r\n-        return f\"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})\"\r\n-\r\n-    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n-        \"\"\"Packs the structure into four floats.\"\"\"\r\n-        raw_bytes = bytes(self)\r\n-        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n-        f1, f2, f3, f4 = struct.unpack('<4f', raw_bytes)\r\n-        return f1, f2, f3, f4\r\n-    \r\n-    def serialize_to_float(self) -> List[float]:\r\n-        \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n-        return [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]\r\n-\r\n-    @staticmethod\r\n-    def from_block(block: 'Block') -> 'SerializedBlock':\r\n-        \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n-        color_enum = get_serialized_color(block.color.name)\r\n-        assert color_enum is not None, f\"Unknown color: {block.color}\"\r\n-        return SerializedBlock(\r\n-            center_x=int(block.center[0]),  # Ensure int conversion\r\n-            center_y=int(block.center[1]),\r\n-            width=int(block.size[0]),\r\n-            height=int(block.size[1]),\r\n-            angle=float(block.angle),  # Ensure float conversion\r\n-            color=color_enum.value  # Store enum as int\r\n-        )\r\n-\r\n-    @classmethod\r\n-    def from_bytes(cls, raw_bytes: bytes) -> 'SerializedBlock':\r\n-        \"\"\"Creates a SerializedBlock from raw bytes.\"\"\"\r\n-        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n-        return cls.from_buffer_copy(raw_bytes)\r\n-\r\n-    @classmethod\r\n-    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n-        \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n-        raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n-        return cls.from_bytes(raw_bytes)\r\n-    \r\n-    @classmethod\r\n-    def from_raw_floats(cls, fs: List[float]) -> 'SerializedBlock':\r\n-        return SerializedBlock(\r\n-            center_x=int(fs[0]),\r\n-            center_y=int(fs[1]),\r\n-            width=int(fs[2]),\r\n-            height=int(fs[3]),\r\n-            angle=fs[4],\r\n-            color=int(fs[5]),\r\n-        )\r\n-\r\n-def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n-    \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n-    serialized_blocks = [SerializedBlock.from_block(block) for block in blocks]\r\n-    return [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n-\r\n-def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n-    \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n-    assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n-    serialized_blocks = [SerializedBlock.from_floats(floats[i], floats[i+1], floats[i+2], floats[i+3]) for i in range(0, len(floats), 4)]\r\n-    return serialized_blocks\r\n"
                },
                {
                    "date": 1739043289946,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,93 @@\n+from src.block import Block\r\n+from ctypes import Structure, c_int16, c_int32, c_float\r\n+import struct\r\n+from typing import Tuple, Optional, List\r\n+from enum import Enum\r\n+\r\n+class SerializedColor(Enum):\r\n+    YELLOW = 1\r\n+    RED = 2\r\n+    BLUE = 4\r\n+\r\n+def get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n+    \"\"\"Maps detected color names to their corresponding SerializedColor enum based on keyword matching.\"\"\"\r\n+    color_name_upper = color_name.upper()\r\n+\r\n+    for enum_member in SerializedColor:\r\n+        if enum_member.name in color_name_upper:\r\n+            return enum_member\r\n+\r\n+    return None  # Return None if no match is found\r\n+\r\n+class SerializedBlock(Structure):\r\n+    _pack_ = 1  # No padding\r\n+    _fields_ = [\r\n+        (\"center_x\", c_int16),\r\n+        (\"center_y\", c_int16),\r\n+        (\"width\", c_int16),\r\n+        (\"height\", c_int16),\r\n+        (\"angle\", c_float),\r\n+        (\"color\", c_int32)\r\n+    ]\r\n+\r\n+    def __str__(self) -> str:\r\n+        return f\"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})\"\r\n+\r\n+    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n+        \"\"\"Packs the structure into four floats.\"\"\"\r\n+        raw_bytes = bytes(self)\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        f1, f2, f3, f4 = struct.unpack('<4f', raw_bytes)\r\n+        return f1, f2, f3, f4\r\n+    \r\n+    def serialize_to_float(self) -> List[float]:\r\n+        \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n+        return [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]\r\n+\r\n+    @staticmethod\r\n+    def from_block(block: 'Block') -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n+        color_enum = get_serialized_color(block.color.name)\r\n+        assert color_enum is not None, f\"Unknown color: {block.color}\"\r\n+        return SerializedBlock(\r\n+            center_x=int(block.center[0]),  # Ensure int conversion\r\n+            center_y=int(block.center[1]),\r\n+            width=int(block.size[0]),\r\n+            height=int(block.size[1]),\r\n+            angle=float(block.angle),  # Ensure float conversion\r\n+            color=color_enum.value  # Store enum as int\r\n+        )\r\n+\r\n+    @classmethod\r\n+    def from_bytes(cls, raw_bytes: bytes) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from raw bytes.\"\"\"\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        return cls.from_buffer_copy(raw_bytes)\r\n+\r\n+    @classmethod\r\n+    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n+        raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n+        return cls.from_bytes(raw_bytes)\r\n+    \r\n+    @classmethod\r\n+    def from_raw_floats(cls, fs: List[float]) -> 'SerializedBlock':\r\n+        return SerializedBlock(\r\n+            center_x=int(fs[0]),\r\n+            center_y=int(fs[1]),\r\n+            width=int(fs[2]),\r\n+            height=int(fs[3]),\r\n+            angle=fs[4],\r\n+            color=int(fs[5]),\r\n+        )\r\n+\r\n+def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n+    \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n+    serialized_blocks =  + [SerializedBlock.from_block(block) for block in blocks]\r\n+    return [0, 0] + [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n+\r\n+def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n+    \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n+    assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n+    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(0, len(floats), 6)]\r\n+    return serialized_blocks\r\n"
                },
                {
                    "date": 1739043308876,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -88,99 +88,6 @@\n \r\n def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n     \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n     assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n-    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(0, len(floats), 6)]\r\n+    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(2, len(floats), 6)]\r\n     return serialized_blocks\r\n-from src.block import Block\r\n-from ctypes import Structure, c_int16, c_int32, c_float\r\n-import struct\r\n-from typing import Tuple, Optional, List\r\n-from enum import Enum\r\n-\r\n-class SerializedColor(Enum):\r\n-    YELLOW = 1\r\n-    RED = 2\r\n-    BLUE = 4\r\n-\r\n-def get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n-    \"\"\"Maps detected color names to their corresponding SerializedColor enum based on keyword matching.\"\"\"\r\n-    color_name_upper = color_name.upper()\r\n-\r\n-    for enum_member in SerializedColor:\r\n-        if enum_member.name in color_name_upper:\r\n-            return enum_member\r\n-\r\n-    return None  # Return None if no match is found\r\n-\r\n-class SerializedBlock(Structure):\r\n-    _pack_ = 1  # No padding\r\n-    _fields_ = [\r\n-        (\"center_x\", c_int16),\r\n-        (\"center_y\", c_int16),\r\n-        (\"width\", c_int16),\r\n-        (\"height\", c_int16),\r\n-        (\"angle\", c_float),\r\n-        (\"color\", c_int32)\r\n-    ]\r\n-\r\n-    def __str__(self) -> str:\r\n-        return f\"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})\"\r\n-\r\n-    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n-        \"\"\"Packs the structure into four floats.\"\"\"\r\n-        raw_bytes = bytes(self)\r\n-        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n-        f1, f2, f3, f4 = struct.unpack('<4f', raw_bytes)\r\n-        return f1, f2, f3, f4\r\n-    \r\n-    def serialize_to_float(self) -> List[float]:\r\n-        \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n-        return [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]\r\n-\r\n-    @staticmethod\r\n-    def from_block(block: 'Block') -> 'SerializedBlock':\r\n-        \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n-        color_enum = get_serialized_color(block.color.name)\r\n-        assert color_enum is not None, f\"Unknown color: {block.color}\"\r\n-        return SerializedBlock(\r\n-            center_x=int(block.center[0]),  # Ensure int conversion\r\n-            center_y=int(block.center[1]),\r\n-            width=int(block.size[0]),\r\n-            height=int(block.size[1]),\r\n-            angle=float(block.angle),  # Ensure float conversion\r\n-            color=color_enum.value  # Store enum as int\r\n-        )\r\n-\r\n-    @classmethod\r\n-    def from_bytes(cls, raw_bytes: bytes) -> 'SerializedBlock':\r\n-        \"\"\"Creates a SerializedBlock from raw bytes.\"\"\"\r\n-        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n-        return cls.from_buffer_copy(raw_bytes)\r\n-\r\n-    @classmethod\r\n-    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n-        \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n-        raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n-        return cls.from_bytes(raw_bytes)\r\n-    \r\n-    @classmethod\r\n-    def from_raw_floats(cls, fs: List[float]) -> 'SerializedBlock':\r\n-        return SerializedBlock(\r\n-            center_x=int(fs[0]),\r\n-            center_y=int(fs[1]),\r\n-            width=int(fs[2]),\r\n-            height=int(fs[3]),\r\n-            angle=fs[4],\r\n-            color=int(fs[5]),\r\n-        )\r\n-\r\n-def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n-    \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n-    serialized_blocks = [[0, 0]] + [SerializedBlock.from_block(block) for block in blocks]\r\n-    return [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n-\r\n-def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n-    \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n-    assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n-    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(0, len(floats), 6)]\r\n-    return serialized_blocks\r\n"
                },
                {
                    "date": 1739044511147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,9 +41,9 @@\n         return f1, f2, f3, f4\r\n     \r\n     def serialize_to_float(self) -> List[float]:\r\n         \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n-        return [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]\r\n+        return [float(num) for num in [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]]\r\n \r\n     @staticmethod\r\n     def from_block(block: 'Block') -> 'SerializedBlock':\r\n         \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n"
                },
                {
                    "date": 1739044716955,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,93 @@\n+from src.block import Block\r\n+from ctypes import Structure, c_int16, c_int32, c_float\r\n+import struct\r\n+from typing import Tuple, Optional, List\r\n+from enum import Enum\r\n+\r\n+class SerializedColor(Enum):\r\n+    YELLOW = 1\r\n+    RED = 2\r\n+    BLUE = 4\r\n+\r\n+def get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n+    \"\"\"Maps detected color names to their corresponding SerializedColor enum based on keyword matching.\"\"\"\r\n+    color_name_upper = color_name.upper()\r\n+\r\n+    for enum_member in SerializedColor:\r\n+        if enum_member.name in color_name_upper:\r\n+            return enum_member\r\n+\r\n+    return None  # Return None if no match is found\r\n+\r\n+class SerializedBlock(Structure):\r\n+    _pack_ = 1  # No padding\r\n+    _fields_ = [\r\n+        (\"center_x\", c_int16),\r\n+        (\"center_y\", c_int16),\r\n+        (\"width\", c_int16),\r\n+        (\"height\", c_int16),\r\n+        (\"angle\", c_float),\r\n+        (\"color\", c_int32)\r\n+    ]\r\n+\r\n+    def __str__(self) -> str:\r\n+        return f\"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})\"\r\n+\r\n+    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n+        \"\"\"Packs the structure into four floats.\"\"\"\r\n+        raw_bytes = bytes(self)\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        f1, f2, f3, f4 = struct.unpack('<4f', raw_bytes)\r\n+        return f1, f2, f3, f4\r\n+    \r\n+    def serialize_to_float(self) -> List[float]:\r\n+        \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n+        return [float(num) for num in [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]]\r\n+\r\n+    @staticmethod\r\n+    def from_block(block: 'Block') -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n+        color_enum = get_serialized_color(block.color.name)\r\n+        assert color_enum is not None, f\"Unknown color: {block.color}\"\r\n+        return SerializedBlock(\r\n+            center_x=int(block.center[0]),  # Ensure int conversion\r\n+            center_y=int(block.center[1]),\r\n+            width=int(block.size[0]),\r\n+            height=int(block.size[1]),\r\n+            angle=float(block.angle),  # Ensure float conversion\r\n+            color=color_enum.value  # Store enum as int\r\n+        )\r\n+\r\n+    @classmethod\r\n+    def from_bytes(cls, raw_bytes: bytes) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from raw bytes.\"\"\"\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        return cls.from_buffer_copy(raw_bytes)\r\n+\r\n+    @classmethod\r\n+    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n+        raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n+        return cls.from_bytes(raw_bytes)\r\n+    \r\n+    @classmethod\r\n+    def from_raw_floats(cls, fs: List[float]) -> 'SerializedBlock':\r\n+        return SerializedBlock(\r\n+            center_x=int(fs[0]),\r\n+            center_y=int(fs[1]),\r\n+            width=int(fs[2]),\r\n+            height=int(fs[3]),\r\n+            angle=fs[4],\r\n+            color=int(fs[5]),\r\n+        )\r\n+\r\n+def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n+    \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n+    serialized_blocks =  [SerializedBlock.from_block(block) for block in blocks]\r\n+    return [0, 0] + [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n+\r\n+def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n+    \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n+    assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n+    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(2, len(floats), 6)]\r\n+    return serialized_blocks\r\n"
                },
                {
                    "date": 1739044754883,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,93 @@\n+from src.block import Block\r\n+from ctypes import Structure, c_int16, c_int32, c_float\r\n+import struct\r\n+from typing import Tuple, Optional, List\r\n+from enum import Enum\r\n+\r\n+class SerializedColor(Enum):\r\n+    YELLOW = 1\r\n+    RED = 2\r\n+    BLUE = 4\r\n+\r\n+def get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n+    \"\"\"Maps detected color names to their corresponding SerializedColor enum based on keyword matching.\"\"\"\r\n+    color_name_upper = color_name.upper()\r\n+\r\n+    for enum_member in SerializedColor:\r\n+        if enum_member.name in color_name_upper:\r\n+            return enum_member\r\n+\r\n+    return None  # Return None if no match is found\r\n+\r\n+class SerializedBlock(Structure):\r\n+    _pack_ = 1  # No padding\r\n+    _fields_ = [\r\n+        (\"center_x\", c_int16),\r\n+        (\"center_y\", c_int16),\r\n+        (\"width\", c_int16),\r\n+        (\"height\", c_int16),\r\n+        (\"angle\", c_float),\r\n+        (\"color\", c_int32)\r\n+    ]\r\n+\r\n+    def __str__(self) -> str:\r\n+        return f\"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})\"\r\n+\r\n+    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n+        \"\"\"Packs the structure into four floats.\"\"\"\r\n+        raw_bytes = bytes(self)\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        f1, f2, f3, f4 = struct.unpack('<4f', raw_bytes)\r\n+        return f1, f2, f3, f4\r\n+    \r\n+    def serialize_to_float(self) -> List[float]:\r\n+        \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n+        return [float(num) for num in [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]]\r\n+\r\n+    @staticmethod\r\n+    def from_block(block: 'Block') -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n+        color_enum = get_serialized_color(block.color.name)\r\n+        assert color_enum is not None, f\"Unknown color: {block.color}\"\r\n+        return SerializedBlock(\r\n+            center_x=int(block.center[0]),  # Ensure int conversion\r\n+            center_y=int(block.center[1]),\r\n+            width=int(block.size[0]),\r\n+            height=int(block.size[1]),\r\n+            angle=float(block.angle),  # Ensure float conversion\r\n+            color=color_enum.value  # Store enum as int\r\n+        )\r\n+\r\n+    @classmethod\r\n+    def from_bytes(cls, raw_bytes: bytes) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from raw bytes.\"\"\"\r\n+        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n+        return cls.from_buffer_copy(raw_bytes)\r\n+\r\n+    @classmethod\r\n+    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n+        \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n+        raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n+        return cls.from_bytes(raw_bytes)\r\n+    \r\n+    @classmethod\r\n+    def from_raw_floats(cls, fs: List[float]) -> 'SerializedBlock':\r\n+        return SerializedBlock(\r\n+            center_x=int(fs[0]),\r\n+            center_y=int(fs[1]),\r\n+            width=int(fs[2]),\r\n+            height=int(fs[3]),\r\n+            angle=fs[4],\r\n+            color=int(fs[5]),\r\n+        )\r\n+\r\n+def serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n+    \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n+    serialized_blocks = [SerializedBlock.from_block(block) for block in blocks]\r\n+    return [0, 0] + [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n+\r\n+def deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n+    \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n+    assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n+    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(2, len(floats), 6)]\r\n+    return serialized_blocks\r\n"
                }
            ],
            "date": 1739042664365,
            "name": "Commit-0",
            "content": "from src.block import Block\r\nfrom ctypes import Structure, c_int16, c_int32, c_float\r\nimport struct\r\nfrom typing import Tuple, Optional, List\r\nfrom enum import Enum\r\n\r\nclass SerializedColor(Enum):\r\n    YELLOW = 1\r\n    RED = 2\r\n    BLUE = 4\r\n\r\ndef get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n    \"\"\"Maps detected color names to their corresponding SerializedColor enum based on keyword matching.\"\"\"\r\n    color_name_upper = color_name.upper()\r\n\r\n    for enum_member in SerializedColor:\r\n        if enum_member.name in color_name_upper:\r\n            return enum_member\r\n\r\n    return None  # Return None if no match is found\r\n\r\nclass SerializedBlock(Structure):\r\n    _pack_ = 1  # No padding\r\n    _fields_ = [\r\n        (\"center_x\", c_int16),\r\n        (\"center_y\", c_int16),\r\n        (\"width\", c_int16),\r\n        (\"height\", c_int16),\r\n        (\"angle\", c_float),\r\n        (\"color\", c_int32)\r\n    ]\r\n\r\n    def __str__(self) -> str:\r\n        return f\"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})\"\r\n\r\n    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n        \"\"\"Packs the structure into four floats.\"\"\"\r\n        raw_bytes = bytes(self)\r\n        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n        f1, f2, f3, f4 = struct.unpack('<4f', raw_bytes)\r\n        return f1, f2, f3, f4\r\n    \r\n    def serialize_to_float(self) -> List[float]:\r\n        \"\"\"Directly serialize the 6 quantities to floats\"\"\"\r\n        return [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]\r\n\r\n    @staticmethod\r\n    def from_block(block: 'Block') -> 'SerializedBlock':\r\n        \"\"\"Creates a SerializedBlock from a Block object.\"\"\"\r\n        color_enum = get_serialized_color(block.color.name)\r\n        assert color_enum is not None, f\"Unknown color: {block.color}\"\r\n        return SerializedBlock(\r\n            center_x=int(block.center[0]),  # Ensure int conversion\r\n            center_y=int(block.center[1]),\r\n            width=int(block.size[0]),\r\n            height=int(block.size[1]),\r\n            angle=float(block.angle),  # Ensure float conversion\r\n            color=color_enum.value  # Store enum as int\r\n        )\r\n\r\n    @classmethod\r\n    def from_bytes(cls, raw_bytes: bytes) -> 'SerializedBlock':\r\n        \"\"\"Creates a SerializedBlock from raw bytes.\"\"\"\r\n        assert len(raw_bytes) == 16, f\"Expected 16 bytes, got {len(raw_bytes)}\"\r\n        return cls.from_buffer_copy(raw_bytes)\r\n\r\n    @classmethod\r\n    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> 'SerializedBlock':\r\n        \"\"\"Creates a SerializedBlock from four floats.\"\"\"\r\n        raw_bytes = struct.pack('<4f', f1, f2, f3, f4)\r\n        return cls.from_bytes(raw_bytes)\r\n\r\ndef serialize_to_floats(blocks: List['Block']) -> List[float]:\r\n    \"\"\"Serializes a list of Blocks into a list of floats.\"\"\"\r\n    serialized_blocks = [SerializedBlock.from_block(block) for block in blocks]\r\n    return [f for serialized_block in serialized_blocks for f in serialized_block.pack_to_floats()]\r\n\r\ndef deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n    \"\"\"Deserializes a list of floats into a list of SerializedBlocks.\"\"\"\r\n    assert len(floats) % 4 == 0, f\"Expected a multiple of 4 floats, got {len(floats)}\"\r\n    serialized_blocks = [SerializedBlock.from_floats(floats[i], floats[i+1], floats[i+2], floats[i+3]) for i in range(0, len(floats), 4)]\r\n    return serialized_blocks\r\n"
        }
    ]
}