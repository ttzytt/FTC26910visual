#!/usr/bin/env python
import contextlib as __stickytape_contextlib

@__stickytape_contextlib.contextmanager
def __stickytape_temporary_dir():
    import tempfile
    import shutil
    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)

with __stickytape_temporary_dir() as __stickytape_working_dir:
    def __stickytape_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __stickytape_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__stickytape_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __stickytape_sys
    __stickytape_sys.path.insert(0, __stickytape_working_dir)

    __stickytape_write_module('src/visualizer.py', b'import cv2\r\nimport numpy as np\r\nfrom typing import List, Dict, Optional, TypedDict\r\nfrom src.color_defs import *\r\nfrom src.block import Block\r\nfrom src.type_defs import *\r\n\r\nNOT_HEADLESS = hasattr(cv2, \'imshow\')\r\n\r\nclass BlockVisualizer:\r\n    """\r\n    Manages two modes:\r\n      - Mode 0: Final detection only (single window)\r\n      - Mode 1: Debug images (multiple windows, intermediate steps) + one additional window\r\n                showing each block region filled with its average HSV color.\r\n\r\n    Parameters:\r\n        show (bool): Whether to display images using OpenCV\'s cv2.imshow(). If False, functions return images.\r\n    """\r\n\r\n    def __init__(self, show: bool = True):\r\n        self.mode = 0\r\n        self.prev_mode = 0  # Force initialization\r\n        self.main_window = "Block Detection"\r\n        self.show = show and NOT_HEADLESS\r\n\r\n    def toggle_mode(self):\r\n        """Switch between mode 0 and mode 1."""\r\n        self.mode = (self.mode + 1) % 2\r\n\r\n    def visualize(self, frame: np.ndarray, blocks: List[Block], debug_images: VizResults) -> VizResults:\r\n        """\r\n        Decide which visualization to show based on mode.\r\n        Only destroy/recreate windows if the mode changed.\r\n\r\n        Parameters:\r\n            frame (np.ndarray): The original frame.\r\n            blocks (List[Block]): List of detected blocks.\r\n            debug_images (Dict[str, np.ndarray]): Dictionary of debug images.\r\n\r\n        Returns:\r\n            Optional[Dict[str, np.ndarray]]: If `self.show=False`, returns a dictionary of images.\r\n        """\r\n        if self.mode != self.prev_mode:\r\n            cv2.destroyAllWindows()\r\n            self.prev_mode = self.mode\r\n\r\n        results : VizResults= {}\r\n        final_result = self.gen_final_result(frame, blocks)\r\n        results[\'final etection\'] = final_result\r\n        if self.mode == 1:\r\n            # debug mode\r\n            results[\'original\'] = frame.copy()\r\n            debug_outputs = self.gen_debug_imgs(debug_images)\r\n            avg_hsv_image = self.gen_avg_hsv_fill(frame, blocks)\r\n\r\n            for name, img in debug_outputs.items(): results[name] = img\r\n            results[\'avg HSV\'] = avg_hsv_image\r\n\r\n        if self.show:\r\n            for name, img in results.items():\r\n                cv2.imshow(name, img)\r\n        return results \r\n\r\n    def gen_final_result(self, frame: np.ndarray, blocks: List[Block]) -> np.ndarray:\r\n        """Draw bounding boxes and put text for each block."""\r\n        output = frame.copy()\r\n        for block in blocks:\r\n            box = cv2.boxPoints(\r\n                (block.center, block.size, block.angle))  # type: ignore\r\n            box = np.intp(box)\r\n            cv2.drawContours(output, [box], 0, block.color.bgr, 2)  # type: ignore\r\n\r\n            # Text lines with extra info: avgH, avgS, avgV\r\n            lines = [\r\n                f"{block.color.name}: {block.angle:.1f} deg",\r\n                f"stdHSV=({block.color_std[0]:.1f}, {block.color_std[1]:.1f}, {block.color_std[2]:.1f})",\r\n                f"avgHSV=({block.mean_hsv[0]:.1f}, {block.mean_hsv[1]:.1f},{block.mean_hsv[2]:.1f})"\r\n            ]\r\n            x0, y0 = int(block.center[0]), int(block.center[1])\r\n            for i, line in enumerate(lines):\r\n                offset_y = i * 15\r\n                cv2.putText(\r\n                    output,\r\n                    line,\r\n                    (x0, y0 + offset_y),\r\n                    cv2.FONT_HERSHEY_SIMPLEX,\r\n                    0.5,\r\n                    (255, 255, 255),\r\n                    1\r\n                )\r\n\r\n        cv2.putText(\r\n            output,\r\n            "Final Detection",\r\n            (10, 30),\r\n            cv2.FONT_HERSHEY_SIMPLEX,\r\n            1.0,\r\n            (0, 255, 0),\r\n            2\r\n        )\r\n\r\n        return output\r\n\r\n    def gen_debug_imgs(self, debug_images: VizResults) -> Dict[str, np.ndarray]:\r\n        """Display intermediate debug images, or return them if `self.show` is False."""\r\n        results = {}\r\n        for name, img in debug_images.items():\r\n            if not isinstance(img, np.ndarray):\r\n                continue\r\n            display = img.copy()\r\n            cv2.putText(display, name, (10, 30), cv2.FONT_HERSHEY_SIMPLEX,\r\n                        1.0, (0, 255, 0), 2)\r\n            \r\n            results[name] = display\r\n\r\n        return results\r\n\r\n    def gen_avg_hsv_fill(self, frame: np.ndarray, blocks: List[Block]) -> np.ndarray:\r\n        """\r\n        Create a black canvas the same size as \'frame\', then fill each block\'s contour\r\n        with the block\'s average HSV color (converted to BGR). Show this in a new window\r\n        or return the processed image.\r\n        """\r\n        canvas = np.zeros_like(frame)  # black canvas\r\n        for block in blocks:\r\n            # Convert mean_hsv -> BGR\r\n            hsv_pixel = np.uint8(\r\n                [[[block.mean_hsv[0], block.mean_hsv[1], block.mean_hsv[2]]]])  # type: ignore\r\n            bgr_pixel = cv2.cvtColor(\r\n                hsv_pixel, cv2.COLOR_HSV2BGR)  # type: ignore\r\n            avg_color = (int(bgr_pixel[0, 0, 0]), int(\r\n                bgr_pixel[0, 0, 1]), int(bgr_pixel[0, 0, 2]))\r\n\r\n            # Fill the contour with this color\r\n            cv2.drawContours(canvas, [block.contour], 0, avg_color, -1)\r\n\r\n        cv2.putText(\r\n            canvas,\r\n            "Blocks filled w/ average HSV",\r\n            (10, 30),\r\n            cv2.FONT_HERSHEY_SIMPLEX,\r\n            1.0,\r\n            (255, 255, 255),\r\n            2\r\n        )\r\n\r\n        return canvas\r\n')
    __stickytape_write_module('src/color_defs.py', b'import numpy as np\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Tuple\r\nfrom src.type_defs import hsv_t, bgr_t\r\n\r\n@dataclass\r\nclass Color:\r\n    """Stores color name, HSV ranges, and BGR values for drawing."""\r\n    name: str\r\n    hsv_ranges: List[Tuple[hsv_t, hsv_t]]\r\n    bgr: bgr_t\r\n\r\n\r\n# ---------- Color Block Detector ----------\r\n\r\ndef compute_hue_std_flip(h_array: np.ndarray, flip_threshold: float = 90.0) -> float:\r\n    # Ensure float\r\n    h_float = h_array.astype(np.float32)\r\n\r\n    # 1) Direct std\r\n    std1 = np.std(h_float)\r\n\r\n    # 2) Flip\r\n    shifted = h_float.copy()\r\n    mask = (shifted < flip_threshold)\r\n    shifted[mask] += 180.0\r\n    std2 = np.std(shifted)\r\n\r\n    return float(min(std1, std2))\r\n\r\n\r\nRED_R9000P = Color(\r\n    name="RED_R9000P",\r\n    hsv_ranges=[\r\n        ((0, 70, 50), (3, 160, 225)),\r\n        ((165, 70, 50), (180, 160, 225)),\r\n    ],\r\n    bgr=(0, 0, 255)\r\n)\r\n\r\nBLUE_R9000P = Color(\r\n    name="BLUE_R9000P",\r\n    hsv_ranges=[\r\n        ((110, 80, 70), (125, 180, 230)),\r\n    ],\r\n    bgr=(255, 0, 0)\r\n)\r\n\r\nYELLOW_R9000P = Color(\r\n    name="YELLOW_R9000P",\r\n    hsv_ranges=[\r\n        ((17, 60, 140), (32, 125, 255)),\r\n    ],\r\n    bgr=(0, 255, 255)\r\n)\r\n\r\nCOLOR_DEF_R9000P = [RED_R9000P, BLUE_R9000P, YELLOW_R9000P]\r\n\r\nRED_LL = Color(\r\n    name="RED_LL",\r\n    hsv_ranges=[\r\n        ((0, 190, 90), (5, 255, 250)),\r\n        ((160, 190, 90), (180, 255, 250)),\r\n    ],\r\n    bgr=(0, 0, 255)\r\n)\r\n\r\nYELLOW_LL = Color(\r\n    name="YELLOW_LL",\r\n    hsv_ranges=[\r\n        ((15, 130, 160), (35, 255, 250)),\r\n    ],\r\n    bgr=(0, 255, 255)\r\n)\r\n\r\nBLUE_LL = Color(\r\n    name="BLUE_LL",\r\n    hsv_ranges=[\r\n        ((100, 220, 70), (125, 255, 230)),\r\n    ],\r\n    bgr=(255, 0, 0)\r\n)\r\n\r\nCOLOR_DEF_LL = [RED_LL, YELLOW_LL, BLUE_LL]')
    __stickytape_write_module('src/type_defs.py', b"from typing import Tuple\r\nimport numpy as np \r\nimport numpy.typing as npt\r\nfrom typing import TypeVar, Annotated, Literal, Dict\r\n\r\nhsv_t = Tuple[int, int, int]\r\nbgr_t = Tuple[int, int, int]\r\n\r\n\r\nDtype = TypeVar('Dtype', bound=np.generic)\r\n\r\n\r\narray_NxNx3_t = Annotated[npt.NDArray[Dtype], Literal['N', 'N', 3]]\r\narray_NxNx1_t = Annotated[npt.NDArray[Dtype], Literal['N', 'N', 1]]\r\n\r\nimg_t = array_NxNx3_t\r\n\r\nimg_hsv_t = array_NxNx3_t\r\n\r\nimg_bgr_t = array_NxNx3_t\r\n\r\nimg_gray_t = array_NxNx1_t\r\n\r\nVizResults = Dict[str, img_t | img_gray_t]")
    __stickytape_write_module('src/block.py', b'import numpy as np\r\nfrom dataclasses import dataclass, field\r\nfrom src.color_defs import Color\r\nfrom typing import List, Tuple\r\n\r\n@dataclass\r\nclass Block:\r\n    """Represents a detected color block with position, size, angle, color info, and HSV stats."""\r\n    center: Tuple[float, float]\r\n    size: Tuple[float, float]\r\n    angle: float\r\n    color: Color\r\n    color_std: Tuple[float, float, float] = (0.0, 0.0, 0.0)\r\n    mean_hsv: Tuple[float, float, float] = (0.0, 0.0, 0.0)\r\n    # store the absolute contour for visualization\r\n    contour: np.ndarray = field(default_factory=lambda: np.array([]))\r\n')
    __stickytape_write_module('src/utils/serializer.py', b'from src.block import Block\r\nfrom ctypes import Structure, c_int16, c_int32, c_float\r\nimport struct\r\nfrom typing import Tuple, Optional, List\r\nfrom enum import Enum\r\n\r\nclass SerializedColor(Enum):\r\n    YELLOW = 1\r\n    RED = 2\r\n    BLUE = 4\r\n\r\ndef get_serialized_color(color_name: str) -> Optional[SerializedColor]:\r\n    """Maps detected color names to their corresponding SerializedColor enum based on keyword matching."""\r\n    color_name_upper = color_name.upper()\r\n\r\n    for enum_member in SerializedColor:\r\n        if enum_member.name in color_name_upper:\r\n            return enum_member\r\n\r\n    return None  # Return None if no match is found\r\n\r\nclass SerializedBlock(Structure):\r\n    _pack_ = 1  # No padding\r\n    _fields_ = [\r\n        ("center_x", c_int16),\r\n        ("center_y", c_int16),\r\n        ("width", c_int16),\r\n        ("height", c_int16),\r\n        ("angle", c_float),\r\n        ("color", c_int32)\r\n    ]\r\n\r\n    def __str__(self) -> str:\r\n        return f"SerializedBlock(center=({self.center_x}, {self.center_y}), size=({self.width}, {self.height}), angle={self.angle}, color={self.color})"\r\n\r\n    def pack_to_floats(self) -> Tuple[float, float, float, float]:\r\n        """Packs the structure into four floats."""\r\n        raw_bytes = bytes(self)\r\n        assert len(raw_bytes) == 16, f"Expected 16 bytes, got {len(raw_bytes)}"\r\n        f1, f2, f3, f4 = struct.unpack(\'<4f\', raw_bytes)\r\n        return f1, f2, f3, f4\r\n    \r\n    def serialize_to_float(self) -> List[float]:\r\n        """Directly serialize the 6 quantities to floats"""\r\n        return [float(num) for num in [self.center_x, self.center_y, self.width, self.height, self.angle, self.color]]\r\n\r\n    @staticmethod\r\n    def from_block(block: \'Block\') -> \'SerializedBlock\':\r\n        """Creates a SerializedBlock from a Block object."""\r\n        color_enum = get_serialized_color(block.color.name)\r\n        assert color_enum is not None, f"Unknown color: {block.color}"\r\n        return SerializedBlock(\r\n            center_x=int(block.center[0]),  # Ensure int conversion\r\n            center_y=int(block.center[1]),\r\n            width=int(block.size[0]),\r\n            height=int(block.size[1]),\r\n            angle=float(block.angle),  # Ensure float conversion\r\n            color=color_enum.value  # Store enum as int\r\n        )\r\n\r\n    @classmethod\r\n    def from_bytes(cls, raw_bytes: bytes) -> \'SerializedBlock\':\r\n        """Creates a SerializedBlock from raw bytes."""\r\n        assert len(raw_bytes) == 16, f"Expected 16 bytes, got {len(raw_bytes)}"\r\n        return cls.from_buffer_copy(raw_bytes)\r\n\r\n    @classmethod\r\n    def from_floats(cls, f1: float, f2: float, f3: float, f4: float) -> \'SerializedBlock\':\r\n        """Creates a SerializedBlock from four floats."""\r\n        raw_bytes = struct.pack(\'<4f\', f1, f2, f3, f4)\r\n        return cls.from_bytes(raw_bytes)\r\n    \r\n    @classmethod\r\n    def from_raw_floats(cls, fs: List[float]) -> \'SerializedBlock\':\r\n        return SerializedBlock(\r\n            center_x=int(fs[0]),\r\n            center_y=int(fs[1]),\r\n            width=int(fs[2]),\r\n            height=int(fs[3]),\r\n            angle=fs[4],\r\n            color=int(fs[5]),\r\n        )\r\n\r\ndef serialize_to_floats(blocks: List[\'Block\']) -> List[float]:\r\n    """Serializes a list of Blocks into a list of floats."""\r\n    serialized_blocks = [SerializedBlock.from_block(block) for block in blocks]\r\n    return [0, 0] + [f for serialized_block in serialized_blocks for f in serialized_block.serialize_to_float()]\r\n\r\ndef deserialize_from_floats(floats: List[float]) -> List[SerializedBlock]:\r\n    """Deserializes a list of floats into a list of SerializedBlocks."""\r\n    assert len(floats) % 4 == 0, f"Expected a multiple of 4 floats, got {len(floats)}"\r\n    serialized_blocks = [SerializedBlock.from_raw_floats(floats[i:i+6]) for i in range(2, len(floats), 6)]\r\n    return serialized_blocks\r\n')
    __stickytape_write_module('color_defs.py', b'import numpy as np\r\nfrom dataclasses import dataclass, field\r\nfrom typing import List, Tuple\r\nfrom src.type_defs import hsv_t, bgr_t\r\n\r\n@dataclass\r\nclass Color:\r\n    """Stores color name, HSV ranges, and BGR values for drawing."""\r\n    name: str\r\n    hsv_ranges: List[Tuple[hsv_t, hsv_t]]\r\n    bgr: bgr_t\r\n\r\n\r\n# ---------- Color Block Detector ----------\r\n\r\ndef compute_hue_std_flip(h_array: np.ndarray, flip_threshold: float = 90.0) -> float:\r\n    # Ensure float\r\n    h_float = h_array.astype(np.float32)\r\n\r\n    # 1) Direct std\r\n    std1 = np.std(h_float)\r\n\r\n    # 2) Flip\r\n    shifted = h_float.copy()\r\n    mask = (shifted < flip_threshold)\r\n    shifted[mask] += 180.0\r\n    std2 = np.std(shifted)\r\n\r\n    return float(min(std1, std2))\r\n\r\n\r\nRED_R9000P = Color(\r\n    name="RED_R9000P",\r\n    hsv_ranges=[\r\n        ((0, 70, 50), (3, 160, 225)),\r\n        ((165, 70, 50), (180, 160, 225)),\r\n    ],\r\n    bgr=(0, 0, 255)\r\n)\r\n\r\nBLUE_R9000P = Color(\r\n    name="BLUE_R9000P",\r\n    hsv_ranges=[\r\n        ((110, 80, 70), (125, 180, 230)),\r\n    ],\r\n    bgr=(255, 0, 0)\r\n)\r\n\r\nYELLOW_R9000P = Color(\r\n    name="YELLOW_R9000P",\r\n    hsv_ranges=[\r\n        ((17, 60, 140), (32, 125, 255)),\r\n    ],\r\n    bgr=(0, 255, 255)\r\n)\r\n\r\nCOLOR_DEF_R9000P = [RED_R9000P, BLUE_R9000P, YELLOW_R9000P]\r\n\r\nRED_LL = Color(\r\n    name="RED_LL",\r\n    hsv_ranges=[\r\n        ((0, 190, 90), (5, 255, 250)),\r\n        ((160, 190, 90), (180, 255, 250)),\r\n    ],\r\n    bgr=(0, 0, 255)\r\n)\r\n\r\nYELLOW_LL = Color(\r\n    name="YELLOW_LL",\r\n    hsv_ranges=[\r\n        ((15, 130, 160), (35, 255, 250)),\r\n    ],\r\n    bgr=(0, 255, 255)\r\n)\r\n\r\nBLUE_LL = Color(\r\n    name="BLUE_LL",\r\n    hsv_ranges=[\r\n        ((100, 220, 70), (125, 255, 230)),\r\n    ],\r\n    bgr=(255, 0, 0)\r\n)\r\n\r\nCOLOR_DEF_LL = [RED_LL, YELLOW_LL, BLUE_LL]')
    from detector_color import ColorDetector
    from src.detector_watershed import WatershedDetector
    from src.detector_meanshift import MeanshiftDetector
    from src.visualizer import BlockVisualizer
    from src.utils.serializer import *
    from color_defs import COLOR_DEF_LL
    from src.utils.serializer import *
    from ctypes import sizeof
    import cv2
    
    MAX_RET_BLK_CNT = 5
    
    def runPipeline(image, llrobot):
        # can change the algorithm with 3 options: contour, watershed, meanshift
        detector = ColorDetector(COLOR_DEF_LL)
        visualizer = BlockVisualizer(show=False)
    
        blocks = detector.process_frame(image)
        image = visualizer.gen_final_result(image, blocks)
    
        # sort the block by area, which can be calculated by contour
        blocks = sorted(blocks, key=lambda x: cv2.contourArea(x.contour), reverse=True)
        
        #select the first MAX_RET_BLK_CNT blocks if exceed
    
        if len(blocks) > MAX_RET_BLK_CNT:
            blocks = blocks[:MAX_RET_BLK_CNT]
    
        serialized_blocks = serialize_to_floats(blocks)
    
        return [], image, serialized_blocks 